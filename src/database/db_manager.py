""" Database connection management module. Supports SQLite and MySQL connections. """ import os import sqlite3 import logging import pandas as pd import yaml from pathlib import Path from typing import Optional, Union, Dict, Any # Uncomment if MySQL connection is needed # import mysql.connector # from mysql.connector import Error as MySQLError logger = logging.getLogger(__name__) class DatabaseManager: """Class for managing database connections and query execution.""" def __init__(self, config_path: str = "config/pipeline_config.yaml"): """ Initialize DatabaseManager. Parameters ---------- config_path: str Configuration file path """ self.config = self._load_config(config_path) self.connection = None self.db_type = self.config['database']['type'] def _load_config(self, config_path: str) -> Dict[str, Any]: """ Load configuration file. Parameters ---------- config_path: str Configuration file path Returns ------- Dict[str, Any] Dictionary containing configuration information """ try: with open(config_path, 'r', encoding='utf-8') as f: config = yaml.safe_load(f) return config except Exception as e: logger.error(f"Failed to load configuration file: {e}") raise def connect(self) -> None: """Connect to the database.""" try: if self.db_type == "sqlite": db_path = self.config['database']['sqlite']['db_path'] # Create directory if it doesn't exist os.makedirs(os.path.dirname(db_path), exist_ok=True) self.connection = sqlite3.connect(db_path) logger.info(f"Connected to SQLite database: {db_path}") elif self.db_type == "mysql": # Uncomment when using MySQL """ mysql_config = self.config['database']['mysql'] self.connection = mysql.connector.connect( host=mysql_config['host'], port=mysql_config['port'], database=mysql_config['database'], user=mysql_config['user'], password=mysql_config['password'] ) logger.info(f"Connected to MySQL database: {mysql_config['host']}:{mysql_config['port']}/{mysql_config['database']}") """ raise NotImplementedError("MySQL connection is not yet implemented.") else: raise ValueError(f"Unsupported database type: {self.db_type}") except Exception as e: logger.error(f"Database connection failed: {e}") raise def disconnect(self) -> None: """Close the database connection.""" if self.connection: self.connection.close() logger.info("Database connection closed") self.connection = None def execute_query(self, query: str, params: Optional[tuple] = None) -> None: """ Execute a query. Parameters ---------- query: str SQL query to execute params: tuple, optional Query parameters """ if not self.connection: self.connect() try: cursor = self.connection.cursor() if params: cursor.execute(query, params) else: cursor.execute(query) self.connection.commit() logger.debug(f"Query executed successfully: {query[:50]}...") except Exception as e: logger.error(f"Query execution failed: {e}, Query: {query[:50]}...") self.connection.rollback() raise finally: cursor.close() def execute_query_fetchall(self, query: str, params: Optional[tuple] = None) -> list: """ Execute a query and return all results. Parameters ---------- query: str SQL query to execute params: tuple, optional Query parameters Returns ------- list List of query results """ if not self.connection: self.connect() try: cursor = self.connection.cursor() if params: cursor.execute(query, params) else: cursor.execute(query) result = cursor.fetchall() logger.debug(f"Query executed and results fetched successfully: {query[:50]}...") return result except Exception as e: logger.error(f"Query execution or result fetching failed: {e}, Query: {query[:50]}...") raise finally: cursor.close() def dataframe_to_sql(self, df: pd.DataFrame, table_name: str, if_exists: str = 'replace', index: bool = False) -> None: """ Save Pandas DataFrame to SQL table. Parameters ---------- df: pd.DataFrame DataFrame to save table_name: str Table name if_exists: str, default='replace' How to behave if the table exists ('replace', 'append', 'fail') index: bool, default=False Whether to include DataFrame index in the table """ if not self.connection: self.connect() try: df.to_sql(table_name, self.connection, if_exists=if_exists, index=index) logger.info(f"DataFrame saved to table '{table_name}' successfully (size: {df.shape})") except Exception as e: logger.error(f"Failed to save DataFrame to table '{table_name}': {e}") raise def read_sql_query(self, query: str, params: Optional[tuple] = None) -> pd.DataFrame: """ Execute SQL query and return results as DataFrame. Parameters ---------- query: str SQL query to execute params: tuple, optional Query parameters Returns ------- pd.DataFrame DataFrame containing query results """ if not self.connection: self.connect() try: if params: df = pd.read_sql_query(query, self.connection, params=params) else: df = pd.read_sql_query(query, self.connection) logger.debug(f"DataFrame created from SQL query successfully: {query[:50]}..., size: {df.shape}") return df except Exception as e: logger.error(f"Failed to create DataFrame from SQL query: {e}, Query: {query[:50]}...") raise def read_sql_table(self, table_name: str) -> pd.DataFrame: """ Read SQL table into DataFrame. Parameters ---------- table_name: str Table name Returns ------- pd.DataFrame DataFrame containing table data """ if not self.connection: self.connect() try: df = pd.read_sql(f"SELECT * FROM {table_name}", self.connection) logger.debug(f"DataFrame created from table '{table_name}' successfully, size: {df.shape}") return df except Exception as e: logger.error(f"Failed to create DataFrame from table '{table_name}': {e}") raise def create_table_if_not_exists(self, table_name: str, schema: str) -> None: """ Create table if it doesn't exist. Parameters ---------- table_name: str Table name schema: str Table schema (CREATE TABLE statement) """ if not self.connection: self.connect() try: self.execute_query(schema) logger.info(f"Table '{table_name}' created or verified successfully") except Exception as e: logger.error(f"Failed to create table '{table_name}': {e}") raise def __enter__(self): """Called when entering context manager.""" self.connect() return self def __exit__(self, exc_type, exc_val, exc_tb): """Called when exiting context manager.""" self.disconnect() def __del__(self): """Destructor.""" self.disconnect() # Usage example if __name__ == "__main__": # Logging setup logging.basicConfig( level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' ) # Create database manager db_manager = DatabaseManager() # Use as context manager with db_manager: # Create table db_manager.create_table_if_not_exists( "sample_table", """ CREATE TABLE IF NOT EXISTS sample_table ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, value REAL, date TEXT ) """ ) # Insert data db_manager.execute_query( "INSERT INTO sample_table (name, value, date) VALUES (?, ?, ?)", ("Test data", 123.45, "2024-04-07") ) # Query data results = db_manager.execute_query_fetchall("SELECT * FROM sample_table") print("Results:", results) # Query as DataFrame df = db_manager.read_sql_table("sample_table") print("\nQuery as DataFrame:") print(df)