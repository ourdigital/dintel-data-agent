""" data analysis 대시보드 애플리케션. Streamlit usage하여 data analysis result visualization. """ import os import yaml import logging import pandas as pd import numpy as np import streamlit as st import matplotlib.pyplot as plt import seaborn as sns import plotly.express as px import plotly.graph_objects as go from pathlib import Path from datetime import datetime, timedelta from typing import Dict, List, Optional, Union, Any, Tuple # 프젝트 루트 directory check하고 configuration if os.path.exists('config'): ROOT_DIR = '.' else: ROOT_DIR = '../..' # import internal modules import sys sys.path.append(ROOT_DIR) from src.database.db_manager import DatabaseManager from src.visualization.plotting import create_correlation_heatmap, plot_feature_importance # 깅 configuration logging.basicConfig( level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' ) logger = logging.getLogger(__name__) class Dashboard: """data analysis result visualization하 Streamlit 대시보드.""" def __init__(self, config_path: str = f"{ROOT_DIR}/config/pipeline_config.yaml"): """ Dashboard initialize. Parameters ---------- config_path: str configuration file 경 """ self.config_path = config_path self.config = self._load_config() self.db_manager = DatabaseManager(config_path) self.setup_page() def _load_config(self) -> Dict[str, Any]: """ load configuration file. Returns ------- Dict[str, Any] dictionary containing configuration information """ try: with open(self.config_path, 'r', encoding='utf-8') as f: config = yaml.safe_load(f) return config except Exception as e: logger.error(f"configuration file load failed: {e}") st.error(f"configuration file load할 number not available: {e}") return {} def setup_page(self) -> None: """페지 기본 configuration 구성.""" app_config = self.config.get('app', {}) # 페지 제목 configuration st.set_page_config( page_title=app_config.get('title', 'data analysis 대시보드'), page_icon='📊', layout='wide' ) # 페지 스타days configuration theme = app_config.get('theme', {}) primary_color = theme.get('primary_color', '#FF4B4B') background_color = theme.get('background_color', '#F0F2F6') # CSS usage자 정 st.markdown(f""" <style>.reportview-container.main.block-container{{ padding-top: 1rem; padding-bottom: 1rem; }}.sidebar.sidebar-content {{ background-color: {background_color}; }}.stButton>button {{ background-color: {primary_color}; color: white; }} </style> """, unsafe_allow_html=True) def run(self) -> None: """대시보드 애플리케션 execute.""" # 제목and 소개 st.title('맞춤형 data analysis 대시보드') st.markdown(""" 대시보드 다양한 source(Google Analytics, Google Ads, Meta Ads 등)from collection한 data analysis하고 visualization. 왼쪽 사드바from 원하 페지 선택하세요. """) # 사드바 메뉴 app_config = self.config.get('app', {}) pages = app_config.get('pages', ['overview', 'traffic_analysis', 'campaign_performance']) default_page = app_config.get('default_page', 'overview') page = st.sidebar.selectbox( '페지 선택', pages, index=pages.index(default_page) if default_page in pages else 0 ) # date 필터 (사드바) st.sidebar.markdown("## date 필터") date_range = st.sidebar.selectbox( '기간 선택', ['최근 7days', '최근 30days', '최근 90days', 'usage자 정'], index=1 ) # usage자 정 date 입력 if date_range == 'usage자 정': end_date = st.sidebar.date_input('closedays', datetime.now()) start_date = st.sidebar.date_input('startdays', end_date - timedelta(days=30)) else: # 선택된 기간according to startdaysand closedays configuration end_date = datetime.now().date() if date_range == '최근 7days': start_date = end_date - timedelta(days=7) elif date_range == '최근 30days': start_date = end_date - timedelta(days=30) elif date_range == '최근 90days': start_date = end_date - timedelta(days=90) # 필터 및 add configuration 접기 with st.sidebar.expander("add 필터 및 configuration"): sources = st.multiselect( 'data source', ['Google Analytics', 'Google Ads', 'Meta Ads', 'Naver Ads', 'Kakao Ads'], default=['Google Analytics', 'Google Ads', 'Meta Ads'] ) metrics = st.multiselect( '지표 선택', ['impressions', 'clicks', 'conversions', 'cost', 'ctr', 'conversion_rate', 'cost_per_conversion'], default=['impressions', 'clicks', 'conversions', 'cost'] ) # 선택된 페지 렌더링 if page == 'overview': self.render_overview(start_date, end_date, sources, metrics) elif page == 'traffic_analysis': self.render_traffic_analysis(start_date, end_date, sources) elif page == 'campaign_performance': self.render_campaign_performance(start_date, end_date, sources, metrics) elif page == 'conversion_analysis': self.render_conversion_analysis(start_date, end_date, sources) elif page == 'custom_reports': self.render_custom_reports(start_date, end_date, sources, metrics) def get_data(self, start_date: datetime.date, end_date: datetime.date, sources: List[str] = None) -> pd.DataFrame: """ 지정된 기간and sourcefor data get. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str], optional data source 목록 Returns ------- pd.DataFrame 필터링된 data """ try: # DBfrom data get query = """ SELECT * FROM processed_data WHERE date BETWEEN ? AND ? """ params = (start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d')) # source 필터 add if sources and len(sources) > 0: source_placeholders = ', '.join(['?'] * len(sources)) query += f" AND source IN ({source_placeholders})" params += tuple(sources) # query execute with self.db_manager: df = self.db_manager.read_sql_query(query, params) if df.empty: logger.warning(f"query result not available: {query}") # 실제 환경from 빈 DataFrame 대신 샘플 data load df = self.load_sample_data(start_date, end_date, sources) return df except Exception as e: logger.error(f"data 조회 중 error occurred: {e}") st.error(f"data 져오 중 error occurred했습니다: {e}") # error occurred 시 샘플 data return return self.load_sample_data(start_date, end_date, sources) def load_sample_data(self, start_date: datetime.date, end_date: datetime.date, sources: List[str] = None) -> pd.DataFrame: """ 테스트 및 개발 위한 샘플 data create. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str], optional data source 목록 Returns ------- pd.DataFrame 샘플 data """ # date range create date_range = pd.date_range(start=start_date, end=end_date) # source 없으면 default value usage if not sources or len(sources) == 0: sources = ['Google Analytics', 'Google Ads', 'Meta Ads'] # 캠페인 목록 campaigns = [ 'Brand_Awareness_Campaign', 'Retargeting_Campaign', 'New_Product_Launch', 'Holiday_Special_Promotion', 'Email_Signup_Campaign' ] # data create data = [] for date in date_range: for source in sources: for campaign in campaigns: # 임 data create impressions = np.random.randint(500, 10000) clicks = np.random.randint(10, int(impressions * 0.1)) cost = round(np.random.uniform(50, 500), 2) conversions = np.random.randint(0, int(clicks * 0.2)) # 파생 지표 계산 ctr = round((clicks / impressions) * 100, 2) if impressions > 0 else 0 conversion_rate = round((conversions / clicks) * 100, 2) if clicks > 0 else 0 cost_per_click = round(cost / clicks, 2) if clicks > 0 else 0 cost_per_conversion = round(cost / conversions, 2) if conversions > 0 else 0 data.append({ 'date': date.strftime('%Y-%m-%d'), 'source': source, 'campaign': campaign, 'impressions': impressions, 'clicks': clicks, 'cost': cost, 'conversions': conversions, 'ctr': ctr, 'conversion_rate': conversion_rate, 'cost_per_click': cost_per_click, 'cost_per_conversion': cost_per_conversion }) return pd.DataFrame(data) def render_overview(self, start_date: datetime.date, end_date: datetime.date, sources: List[str], metrics: List[str]) -> None: """ 개요 페지 렌더링. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str] data source 목록 metrics: List[str] 표시할 지표 목록 """ st.header('개요') st.write(f"data 기간: {start_date} ~ {end_date}") # data load with st.spinner('data 불러오 중...'): df = self.get_data(start_date, end_date, sources) if df.empty: st.warning('선택한 기간 및 필터 해당하 data not available.') return # 주요 지표 카드 st.subheader('주요 지표') # 전체 합계 계산 total_impressions = int(df['impressions'].sum()) total_clicks = int(df['clicks'].sum()) total_conversions = int(df['conversions'].sum()) total_cost = float(df['cost'].sum()) # 평균 계산 avg_ctr = (total_clicks / total_impressions * 100) if total_impressions > 0 else 0 avg_conversion_rate = (total_conversions / total_clicks * 100) if total_clicks > 0 else 0 avg_cost_per_click = total_cost / total_clicks if total_clicks > 0 else 0 avg_cost_per_conversion = total_cost / total_conversions if total_conversions > 0 else 0 # 메트릭 카드 표시 cols = st.columns(4) cols[0].metric("노출 number", f"{total_impressions:,}") cols[1].metric("클릭 number", f"{total_clicks:,}") cols[2].metric("전환 number", f"{total_conversions:,}") cols[3].metric("총 비용", f"₩{total_cost:,.2f}") cols = st.columns(4) cols[0].metric("평균 CTR", f"{avg_ctr:.2f}%") cols[1].metric("평균 전환율", f"{avg_conversion_rate:.2f}%") cols[2].metric("평균 CPC", f"₩{avg_cost_per_click:.2f}") cols[3].metric("평균 CPA", f"₩{avg_cost_per_conversion:.2f}") # 시계columns chart st.subheader('time 따른 추') # days별 data 집계 daily_data = df.groupby('date')[metrics].sum().reset_index() daily_data['date'] = pd.to_datetime(daily_data['date']) daily_data = daily_data.sort_values('date') # chart 선택기 selected_metric = st.selectbox('지표 선택', metrics, index=0) # Plotly usage한 인터랙티브 chart fig = px.line( daily_data, x='date', y=selected_metric, title=f'days별 {selected_metric} 추', labels={'date': 'date', selected_metric: selected_metric} ) st.plotly_chart(fig, use_container_width=True) # source별 비교 st.subheader('source별 비교') # source별 data 집계 source_data = df.groupby('source')[metrics].sum().reset_index() # 선택할 지표 source_metric = st.selectbox('비교 지표 선택', metrics, index=0, key='source_metric') # 바 chart fig = px.bar( source_data, x='source', y=source_metric, title=f'source별 {source_metric}', labels={'source': 'source', source_metric: source_metric}, color='source' ) st.plotly_chart(fig, use_container_width=True) # 캠페인 성and st.subheader('캠페인 성and') # 캠페인별 data 집계 campaign_data = df.groupby('campaign')[metrics].sum().reset_index() campaign_data = campaign_data.sort_values(metrics[0], ascending=False) # 선택할 지표 campaign_metric = st.selectbox('캠페인 성and 지표', metrics, index=0, key='campaign_metric') # number평 막대 chart fig = px.bar( campaign_data.head(10), # 상위 10개만 표시 y='campaign', x=campaign_metric, title=f'캠페인별 {campaign_metric} (상위 10개)', labels={'campaign': '캠페인', campaign_metric: campaign_metric}, orientation='h', color=campaign_metric ) st.plotly_chart(fig, use_container_width=True) # 상관관계 analysis st.subheader('지표 간 상관관계') # number형 columns만 선택 numeric_cols = df.select_dtypes(include=['number']).columns.tolist() # 상관관계 계산 corr = df[numeric_cols].corr() # 히트맵 fig, ax = plt.subplots(figsize=(10, 8)) sns.heatmap(corr, annot=True, cmap='coolwarm', center=0, ax=ax) plt.title('지표 간 상관관계') plt.tight_layout() st.pyplot(fig) def render_traffic_analysis(self, start_date: datetime.date, end_date: datetime.date, sources: List[str]) -> None: """ 트래픽 analysis 페지 렌더링. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str] data source 목록 """ st.header('트래픽 analysis') st.write(f"data 기간: {start_date} ~ {end_date}") # data load with st.spinner('data 불러오 중...'): df = self.get_data(start_date, end_date, sources) if df.empty: st.warning('선택한 기간 및 필터 해당하 data not available.') return # 샘플 data 장치 type add (실제 환경from DBfrom 져옴) if 'device' not in df.columns: devices = ['Desktop', 'Mobile', 'Tablet'] df['device'] = np.random.choice(devices, size=len(df)) # days별 트래픽 추 st.subheader('days별 트래픽 추') daily_traffic = df.groupby('date')[['impressions', 'clicks']].sum().reset_index() daily_traffic['date'] = pd.to_datetime(daily_traffic['date']) daily_traffic = daily_traffic.sort_values('date') # 복합 지표 chart fig = go.Figure() # 노출 data (왼쪽 y축) fig.add_trace( go.Bar( x=daily_traffic['date'], y=daily_traffic['impressions'], name='노출 number', marker_color='lightblue' ) ) # 클릭 data (오른쪽 y축) fig.add_trace( go.Scatter( x=daily_traffic['date'], y=daily_traffic['clicks'], name='클릭 number', marker_color='red', yaxis='y2' ) ) # 레아웃 configuration fig.update_layout( title='days별 노출 및 클릭 추', xaxis=dict(title='date'), yaxis=dict(title='노출 number', side='left', showgrid=False), yaxis2=dict(title='클릭 number', side='right', overlaying='y', showgrid=False), legend=dict(x=0.01, y=0.99), hovermode='x unified' ) st.plotly_chart(fig, use_container_width=True) # 장치별 트래픽 st.subheader('장치별 트래픽') device_traffic = df.groupby('device')[['impressions', 'clicks', 'conversions']].sum().reset_index() # 탭 create device_tabs = st.tabs(['노출', '클릭', '전환']) # 노출 탭 with device_tabs[0]: fig = px.pie( device_traffic, values='impressions', names='device', title='장치별 노출 분포', hole=0.4 ) st.plotly_chart(fig, use_container_width=True) # 클릭 탭 with device_tabs[1]: fig = px.pie( device_traffic, values='clicks', names='device', title='장치별 클릭 분포', hole=0.4 ) st.plotly_chart(fig, use_container_width=True) # 전환 탭 with device_tabs[2]: fig = px.pie( device_traffic, values='conversions', names='device', title='장치별 전환 분포', hole=0.4 ) st.plotly_chart(fig, use_container_width=True) # source별 트래픽 추 st.subheader('source별 트래픽 추') # source 및 date별 data 집계 source_daily = df.groupby(['source', 'date'])['clicks'].sum().reset_index() source_daily['date'] = pd.to_datetime(source_daily['date']) source_daily = source_daily.sort_values('date') # source별 선 graph fig = px.line( source_daily, x='date', y='clicks', color='source', title='source별 days별 클릭 추', labels={'date': 'date', 'clicks': '클릭 number', 'source': 'source'} ) st.plotly_chart(fig, use_container_width=True) # 트래픽 세부 analysis st.subheader('트래픽 세부 analysis') # source 및 디바스별 CTR 계산 detailed = df.groupby(['source', 'device']).agg({ 'impressions': 'sum', 'clicks': 'sum' }).reset_index() detailed['ctr'] = (detailed['clicks'] / detailed['impressions'] * 100).round(2) # 히트맵 chart fig = px.density_heatmap( detailed, x='source', y='device', z='ctr', title='source 및 장치별 CTR (%)', labels={'source': 'source', 'device': '장치', 'ctr': 'CTR (%)'}, color_continuous_scale='YlOrRd' ) st.plotly_chart(fig, use_container_width=True) # 상세 data table st.subheader('상세 data') # 집계 data table summary = df.groupby(['source', 'device']).agg({ 'impressions': 'sum', 'clicks': 'sum', 'conversions': 'sum', 'cost': 'sum' }).reset_index() summary['ctr'] = (summary['clicks'] / summary['impressions'] * 100).round(2) summary['conversion_rate'] = (summary['conversions'] / summary['clicks'] * 100).round(2) summary['cost_per_click'] = (summary['cost'] / summary['clicks']).round(2) # data 포맷팅 summary['impressions'] = summary['impressions'].map('{:,.0f}'.format) summary['clicks'] = summary['clicks'].map('{:,.0f}'.format) summary['conversions'] = summary['conversions'].map('{:,.0f}'.format) summary['cost'] = summary['cost'].map('₩{:,.2f}'.format) summary['ctr'] = summary['ctr'].map('{:.2f}%'.format) summary['conversion_rate'] = summary['conversion_rate'].map('{:.2f}%'.format) summary['cost_per_click'] = summary['cost_per_click'].map('₩{:.2f}'.format) st.dataframe(summary, use_container_width=True) def render_campaign_performance(self, start_date: datetime.date, end_date: datetime.date, sources: List[str], metrics: List[str]) -> None: """ 캠페인 성and 페지 렌더링. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str] data source 목록 metrics: List[str] 표시할 지표 목록 """ st.header('캠페인 성and analysis') st.write(f"data 기간: {start_date} ~ {end_date}") # data load with st.spinner('data 불러오 중...'): df = self.get_data(start_date, end_date, sources) if df.empty: st.warning('선택한 기간 및 필터 해당하 data not available.') return # 캠페인별 성and 요약 st.subheader('캠페인별 성and 요약') # 캠페인별 data 집계 campaign_summary = df.groupby('campaign').agg({ 'impressions': 'sum', 'clicks': 'sum', 'conversions': 'sum', 'cost': 'sum' }).reset_index() # 파생 지표 계산 campaign_summary['ctr'] = (campaign_summary['clicks'] / campaign_summary['impressions'] * 100).round(2) campaign_summary['conversion_rate'] = (campaign_summary['conversions'] / campaign_summary['clicks'] * 100).round(2) campaign_summary['cost_per_click'] = (campaign_summary['cost'] / campaign_summary['clicks']).round(2) campaign_summary['cost_per_conversion'] = (campaign_summary['cost'] / campaign_summary['conversions']).round(2) campaign_summary['cost_per_conversion'] = campaign_summary['cost_per_conversion'].replace([np.inf, -np.inf], np.nan) # 캠페인 선택기 campaigns = campaign_summary['campaign'].tolist() selected_campaign = st.selectbox('캠페인 선택', campaigns) # 선택된 캠페인 data selected_data = campaign_summary[campaign_summary['campaign'] == selected_campaign].iloc[0] # 캠페인 성and 카드 cols = st.columns(4) cols[0].metric("노출 number", f"{selected_data['impressions']:,}") cols[1].metric("클릭 number", f"{selected_data['clicks']:,}") cols[2].metric("전환 number", f"{selected_data['conversions']:,}") cols[3].metric("총 비용", f"₩{selected_data['cost']:,.2f}") cols = st.columns(4) cols[0].metric("CTR", f"{selected_data['ctr']:.2f}%") cols[1].metric("전환율", f"{selected_data['conversion_rate']:.2f}%") cols[2].metric("CPC", f"₩{selected_data['cost_per_click']:.2f}") cols[3].metric("CPA", f"₩{selected_data['cost_per_conversion']:.2f}" if not np.isnan(selected_data['cost_per_conversion']) else "N/A") # 캠페인별 비교 st.subheader('캠페인 비교') # 표시할 지표 선택 compare_metric = st.selectbox('비교 지표 선택', metrics) # 상위 10개 캠페인만 표시 top_campaigns = campaign_summary.sort_values(compare_metric, ascending=False).head(10) # 바 chart fig = px.bar( top_campaigns, y='campaign', x=compare_metric, title=f'캠페인별 {compare_metric} 비교 (상위 10개)', labels={'campaign': '캠페인', compare_metric: compare_metric}, orientation='h', color=compare_metric, template='plotly_white' ) st.plotly_chart(fig, use_container_width=True) # 캠페인 효율성 analysis st.subheader('캠페인 효율성 analysis') # 산점도 chart fig = px.scatter( campaign_summary, x='cost', y='conversions', size='clicks', color='conversion_rate', hover_name='campaign', title='비용 vs 전환 number (버블 size: 클릭 number, 색상: 전환율)', labels={ 'cost': '총 비용', 'conversions': '전환 number', 'clicks': '클릭 number', 'conversion_rate': '전환율 (%)' }, color_continuous_scale='Viridis' ) st.plotly_chart(fig, use_container_width=True) # source별 캠페인 성and st.subheader('source별 캠페인 성and') # source 및 캠페인별 data 집계 source_campaign = df.groupby(['source', 'campaign']).agg({ 'impressions': 'sum', 'clicks': 'sum', 'conversions': 'sum', 'cost': 'sum' }).reset_index() source_campaign['conversion_rate'] = (source_campaign['conversions'] / source_campaign['clicks'] * 100).round(2) # 선택된 캠페인 data만 필터링 selected_campaign_data = source_campaign[source_campaign['campaign'] == selected_campaign] # source별 바 chart fig = px.bar( selected_campaign_data, x='source', y=['impressions', 'clicks', 'conversions'], title=f'source별 "{selected_campaign}" 캠페인 성and', labels={'source': 'source', 'value': 'value', 'variable': '지표'}, barmode='group' ) st.plotly_chart(fig, use_container_width=True) # 캠페인 성and 상세 data st.subheader('캠페인 성and 상세 data') # 캠페인 data 포맷팅 display_data = campaign_summary.copy() display_data['impressions'] = display_data['impressions'].map('{:,.0f}'.format) display_data['clicks'] = display_data['clicks'].map('{:,.0f}'.format) display_data['conversions'] = display_data['conversions'].map('{:,.0f}'.format) display_data['cost'] = display_data['cost'].map('₩{:,.2f}'.format) display_data['ctr'] = display_data['ctr'].map('{:.2f}%'.format) display_data['conversion_rate'] = display_data['conversion_rate'].map('{:.2f}%'.format) display_data['cost_per_click'] = display_data['cost_per_click'].map('₩{:.2f}'.format) display_data['cost_per_conversion'] = display_data['cost_per_conversion'].apply( lambda x: '₩{:.2f}'.format(x) if not np.isnan(x) else 'N/A' ) st.dataframe(display_data, use_container_width=True) def render_conversion_analysis(self, start_date: datetime.date, end_date: datetime.date, sources: List[str]) -> None: """ 전환 analysis 페지 렌더링. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str] data source 목록 """ st.header('전환 analysis') st.write(f"data 기간: {start_date} ~ {end_date}") # data load with st.spinner('data 불러오 중...'): df = self.get_data(start_date, end_date, sources) if df.empty: st.warning('선택한 기간 및 필터 해당하 data not available.') return # 샘플 data 전환 type add (실제 환경from DBfrom 져옴) if 'conversion_type' not in df.columns: conversion_types = ['구매', '양식 제출', '회원입', '다운load', '문'] df['conversion_type'] = np.random.choice(conversion_types, size=len(df)) # 전환 치 add conversion_values = { '구매': (50000, 200000), '양식 제출': (10000, 30000), '회원입': (5000, 15000), '다운load': (2000, 10000), '문': (15000, 40000) } df['conversion_value'] = df.apply( lambda row: np.random.uniform(*conversion_values[row['conversion_type']]) if row['conversions'] > 0 else 0, axis=1 ) # 전환 개요 st.subheader('전환 개요') # 전체 전환 지표 total_conversions = int(df['conversions'].sum()) total_conversion_value = float(df['conversion_value'].sum()) if 'conversion_value' in df.columns else 0 avg_conversion_rate = float((df['conversions'].sum() / df['clicks'].sum() * 100)) if df['clicks'].sum() > 0 else 0 avg_conversion_value = float(total_conversion_value / total_conversions) if total_conversions > 0 else 0 # 전환 지표 카드 cols = st.columns(4) cols[0].metric("총 전환 number", f"{total_conversions:,}") cols[1].metric("총 전환 치", f"₩{total_conversion_value:,.2f}") cols[2].metric("평균 전환율", f"{avg_conversion_rate:.2f}%") cols[3].metric("평균 전환 치", f"₩{avg_conversion_value:,.2f}") # days별 전환 추 st.subheader('days별 전환 추') # days별 data 집계 daily_conversions = df.groupby('date').agg({ 'conversions': 'sum', 'conversion_value': 'sum' if 'conversion_value' in df.columns else lambda x: 0, 'cost': 'sum' }).reset_index() daily_conversions['date'] = pd.to_datetime(daily_conversions['date']) daily_conversions = daily_conversions.sort_values('date') # 복합 chart create fig = go.Figure() # 전환 number (막대 chart) fig.add_trace( go.Bar( x=daily_conversions['date'], y=daily_conversions['conversions'], name='전환 number', marker_color='lightgreen' ) ) # 전환 치 (선 chart, 오른쪽 y축) if 'conversion_value' in daily_conversions.columns: fig.add_trace( go.Scatter( x=daily_conversions['date'], y=daily_conversions['conversion_value'], name='전환 치', marker_color='darkblue', yaxis='y2' ) ) # 레아웃 configuration fig.update_layout( title='days별 전환 추', xaxis=dict(title='date'), yaxis=dict(title='전환 number', side='left', showgrid=False), yaxis2=dict(title='전환 치 (₩)', side='right', overlaying='y', showgrid=False), legend=dict(x=0.01, y=0.99), hovermode='x unified' ) st.plotly_chart(fig, use_container_width=True) # 전환 type별 analysis if 'conversion_type' in df.columns: st.subheader('전환 type별 analysis') # 전환 type별 data 집계 conversion_type_data = df.groupby('conversion_type').agg({ 'conversions': 'sum', 'conversion_value': 'sum', 'cost': 'sum' }).reset_index() # ROAS 계산 (Return On Ad Spend) conversion_type_data['roas'] = (conversion_type_data['conversion_value'] / conversion_type_data['cost'] * 100).round(2) # 도넛 chart (전환 number) fig = px.pie( conversion_type_data, values='conversions', names='conversion_type', title='전환 type별 전환 number 분포', hole=0.4 ) st.plotly_chart(fig, use_container_width=True) # 전환 치 chart fig = px.bar( conversion_type_data.sort_values('conversion_value', ascending=False), x='conversion_type', y='conversion_value', title='전환 type별 총 전환 치', color='conversion_type', labels={'conversion_type': '전환 type', 'conversion_value': '전환 치 (₩)'} ) st.plotly_chart(fig, use_container_width=True) # ROAS chart fig = px.bar( conversion_type_data.sort_values('roas', ascending=False), x='conversion_type', y='roas', title='전환 type별 ROAS (투자 number익률)', color='roas', labels={'conversion_type': '전환 type', 'roas': 'ROAS (%)'}, color_continuous_scale='RdYlGn' ) st.plotly_chart(fig, use_container_width=True) # source별 전환 성and st.subheader('source별 전환 성and') # source별 data 집계 source_conversion = df.groupby('source').agg({ 'conversions': 'sum', 'clicks': 'sum', 'cost': 'sum', 'conversion_value': 'sum' if 'conversion_value' in df.columns else lambda x: 0 }).reset_index() # 파생 지표 계산 source_conversion['conversion_rate'] = (source_conversion['conversions'] / source_conversion['clicks'] * 100).round(2) source_conversion['cost_per_conversion'] = (source_conversion['cost'] / source_conversion['conversions']).round(2) source_conversion['roas'] = (source_conversion['conversion_value'] / source_conversion['cost'] * 100).round(2) if 'conversion_value' in df.columns else 0 # source별 전환율 chart fig = px.bar( source_conversion.sort_values('conversion_rate', ascending=False), x='source', y='conversion_rate', title='source별 전환율', color='conversion_rate', labels={'source': 'source', 'conversion_rate': '전환율 (%)'}, color_continuous_scale='Blues' ) st.plotly_chart(fig, use_container_width=True) # source별 비용 효율성 chart fig = px.scatter( source_conversion, x='cost_per_conversion', y='conversion_rate', size='conversions', color='source', hover_name='source', title='source별 비용 효율성 analysis', labels={ 'cost_per_conversion': '전환당 비용 (CPA)', 'conversion_rate': '전환율 (%)', 'conversions': '전환 number' } ) st.plotly_chart(fig, use_container_width=True) # 전환 성and 요약 표 st.subheader('전환 성and 요약') # data 포맷팅 display_data = source_conversion.copy() display_data['conversions'] = display_data['conversions'].map('{:,.0f}'.format) display_data['clicks'] = display_data['clicks'].map('{:,.0f}'.format) display_data['cost'] = display_data['cost'].map('₩{:,.2f}'.format) display_data['conversion_rate'] = display_data['conversion_rate'].map('{:.2f}%'.format) display_data['cost_per_conversion'] = display_data['cost_per_conversion'].map('₩{:.2f}'.format) if 'conversion_value' in display_data.columns: display_data['conversion_value'] = display_data['conversion_value'].map('₩{:,.2f}'.format) display_data['roas'] = display_data['roas'].map('{:.2f}%'.format) st.dataframe(display_data, use_container_width=True) def render_custom_reports(self, start_date: datetime.date, end_date: datetime.date, sources: List[str], metrics: List[str]) -> None: """ usage자 정 report 페지 렌더링. Parameters ---------- start_date: datetime.date startdays end_date: datetime.date closedays sources: List[str] data source 목록 metrics: List[str] 표시할 지표 목록 """ st.header('usage자 정 report') st.write(f"data 기간: {start_date} ~ {end_date}") # data load with st.spinner('data 불러오 중...'): df = self.get_data(start_date, end_date, sources) if df.empty: st.warning('선택한 기간 및 필터 해당하 data not available.') return # report create기 st.subheader('report create기') # report type 선택 report_type = st.selectbox( 'report type', ['시계columns analysis', '비교 analysis', '상관관계 analysis', 'data table'] ) # 시계columns analysis if report_type == '시계columns analysis': # X축 선택 x_axis = st.selectbox('X축 (date)', ['date']) # Y축 선택 (복number 선택 available) y_axis = st.multiselect('Y축 (지표)', metrics, default=metrics[0] if metrics else None) # 그룹화 선택 groupby = st.selectbox('그룹화', ['없음', 'source', 'campaign', 'device']) if y_axis: # data 준비 if groupby == '없음': # days별 집계 chart_data = df.groupby(x_axis)[y_axis].sum().reset_index() chart_data[x_axis] = pd.to_datetime(chart_data[x_axis]) chart_data = chart_data.sort_values(x_axis) # 선 chart fig = px.line( chart_data, x=x_axis, y=y_axis, title='시계columns analysis', labels={x_axis: 'date'} ) else: # 그룹별 및 days별 집계 chart_data = df.groupby([groupby, x_axis])[y_axis].sum().reset_index() chart_data[x_axis] = pd.to_datetime(chart_data[x_axis]) chart_data = chart_data.sort_values(x_axis) # 선 chart (그룹별 색상 구분) fig = px.line( chart_data, x=x_axis, y=y_axis[0] if len(y_axis) == 1 else y_axis, color=groupby, title=f'{groupby}별 시계columns analysis', labels={x_axis: 'date', groupby: groupby} ) st.plotly_chart(fig, use_container_width=True) # 비교 analysis elif report_type == '비교 analysis': # X축 선택 x_axis = st.selectbox('X축 (범주)', ['source', 'campaign', 'device', 'conversion_type']) # Y축 선택 y_axis = st.selectbox('Y축 (지표)', metrics) # 정렬 method sort_by = st.radio('정렬 method', ['value 기준', '범주 기준']) # graph type chart_type = st.radio('graph type', ['막대 graph', '원형 graph']) # 상위 항목 필터링 top_n = st.slider('상위 표시 number', min_value=3, max_value=20, value=10) # data 준비 chart_data = df.groupby(x_axis)[y_axis].sum().reset_index() # 정렬 if sort_by == 'value 기준': chart_data = chart_data.sort_values(y_axis, ascending=False) else: chart_data = chart_data.sort_values(x_axis) # 상위 항목 필터링 chart_data = chart_data.head(top_n) # chart create if chart_type == '막대 graph': # 막대 graph fig = px.bar( chart_data, x=x_axis, y=y_axis, title=f'{x_axis}별 {y_axis} 비교', labels={x_axis: x_axis, y_axis: y_axis}, color=y_axis ) else: # 원형 graph fig = px.pie( chart_data, values=y_axis, names=x_axis, title=f'{x_axis}별 {y_axis} 분포' ) st.plotly_chart(fig, use_container_width=True) # 상관관계 analysis elif report_type == '상관관계 analysis': # number형 columns만 선택 numeric_cols = df.select_dtypes(include=['number']).columns.tolist() # X축 선택 x_axis = st.selectbox('X축', numeric_cols) # Y축 선택 y_axis = st.selectbox('Y축', [col for col in numeric_cols if col != x_axis]) # 그룹화 선택 groupby = st.selectbox('색상 구분', ['없음', 'source', 'campaign', 'device']) # size 선택 size_by = st.selectbox('size 변number', ['없음'] + [col for col in numeric_cols if col != x_axis and col != y_axis]) # chart create if groupby == '없음': # 단순 산점도 fig = px.scatter( df, x=x_axis, y=y_axis, size=size_by if size_by != '없음' else None, title=f'{x_axis} vs {y_axis} 상관관계', labels={x_axis: x_axis, y_axis: y_axis}, trendline='ols' if st.checkbox('추세선 표시') else None ) else: # 그룹별 산점도 fig = px.scatter( df, x=x_axis, y=y_axis, color=groupby, size=size_by if size_by != '없음' else None, hover_name=groupby, title=f'{x_axis} vs {y_axis} 상관관계 ({groupby}별)', labels={x_axis: x_axis, y_axis: y_axis, groupby: groupby} ) st.plotly_chart(fig, use_container_width=True) # 상관계number 계산 corr = df[[x_axis, y_axis]].corr().iloc[0, 1] st.info(f"{x_axis}and {y_axis} 사 상관계number: {corr:.4f}") # data table elif report_type == 'data table': # table format 선택 table_type = st.radio('table format', ['요약 table', '피벗 table']) if table_type == '요약 table': # 그룹화 선택 groupby_cols = st.multiselect('그룹화 기준', ['source', 'campaign', 'device', 'date', 'conversion_type']) # 집계 지표 선택 agg_metrics = st.multiselect('집계 지표', metrics) if groupby_cols and agg_metrics: # data 집계 agg_dict = {metric: 'sum' for metric in agg_metrics} table_data = df.groupby(groupby_cols).agg(agg_dict).reset_index() # table 표시 st.dataframe(table_data, use_container_width=True) # CSV 다운load 버튼 csv = table_data.to_csv(index=False) st.download_button( label="CSV 다운load", data=csv, file_name="custom_report.csv", mime="text/csv" ) else: # 피벗 table # rows 선택 rows = st.selectbox('rows', ['source', 'campaign', 'device', 'conversion_type']) # columns 선택 columns = st.selectbox('columns', ['없음', 'source', 'campaign', 'device', 'conversion_type']) columns = None if columns == '없음' else columns # value 선택 values = st.selectbox('value', metrics) # 집계 function 선택 aggfunc = st.selectbox('집계 function', ['합계', '평균', '최대value', '최소value']) # 집계 function 매핑 aggfunc_map = { '합계': 'sum', '평균': 'mean', '최대value': 'max', '최소value': 'min' } # 피벗 table create if rows and values: pivot = pd.pivot_table( df, values=values, index=rows, columns=columns, aggfunc=aggfunc_map[aggfunc], fill_value=0 ) # table 표시 st.dataframe(pivot, use_container_width=True) # CSV 다운load 버튼 csv = pivot.to_csv() st.download_button( label="CSV 다운load", data=csv, file_name="pivot_table.csv", mime="text/csv" ) # 원시 data 표시 with st.expander("원시 data 보기"): st.dataframe(df, use_container_width=True) # 애플리케션 execute if __name__ == "__main__": # 대시보드 create 및 execute dashboard = Dashboard() dashboard.run()